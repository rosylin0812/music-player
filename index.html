<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1DB954">
    <meta name="description" content="Offline music player for dharma practice">
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIk11c2ljIFBsYXllciIsCiAgInNob3J0X25hbWUiOiAiTXVzaWMiLAogICJkZXNjcmlwdGlvbiI6ICJPZmZsaW5lIG11c2ljIHBsYXllciBmb3IgZGhhcm1hIHByYWN0aWNlIiwKICAic3RhcnRfdXJsIjogIi8iLAogICJkaXNwbGF5IjogInN0YW5kYWxvbmUiLAogICJiYWNrZ3JvdW5kX2NvbG9yIjogIiMwMDAwMDAiLAogICJ0aGVtZV9jb2xvciI6ICIjMURCOTU0IiwKICAiaWNvbnMiOiBbCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScxOTInIGhlaWdodD0nMTkyJyUzRSUzQ3JlY3Qgd2lkdGg9JzE5MicgaGVpZ2h0PScxOTInIGZpbGw9JyUyMzFEQjk1NCcvJTNFJTNDdGV4dCB4PScxMCcgeT0nMTMwJyBmb250LXNpemU9JzEyMCcgZmlsbD0nd2hpdGUnJTNF8J+OtSUzQy90ZXh0JTNFJTNDL3N2ZyUzRSIsCiAgICAgICJzaXplcyI6ICIxOTJ4MTkyIiwKICAgICAgInR5cGUiOiAiaW1hZ2Uvc3ZnK3htbCIKICAgIH0sCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc1MTInIGhlaWdodD0nNTEyJyUzRSUzQ3JlY3Qgd2lkdGg9JzUxMicgaGVpZ2h0PSc1MTInIGZpbGw9JyUyMzFEQjk1NCcvJTNFJTNDdGV4dCB4PSczMCcgeT0nMzYwJyBmb250LXNpemU9JzM1MCcgZmlsbD0nd2hpdGUnJTNF8J+OtSUzQy90ZXh0JTNFJTNDL3N2ZyUzRSIsCiAgICAgICJzaXplcyI6ICI1MTJ4NTEyIiwKICAgICAgInR5cGUiOiAiaW1hZ2Uvc3ZnK3htbCIKICAgIH0KICBdCn0=">
    <title>Music Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow: hidden;
        }
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: -100%;
                top: 0;
                bottom: 0;
                width: 75%;
                max-width: 280px;
                z-index: 50;
                transition: left 0.3s ease;
            }
            .sidebar.open {
                left: 0;
            }
            .overlay {
                display: none;
                position: fixed;
                inset: 0;
                background: rgba(0,0,0,0.5);
                z-index: 40;
            }
            .overlay.open {
                display: block;
            }
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.3s ease;
        }
    </style>
</head>
<body class="bg-black text-white">
    <div id="root"></div>

    <script>
        const { useState, useEffect, useRef } = React;

        // IndexedDB Manager
        const DB_NAME = 'MusicPlayerDB';
        const DB_VERSION = 1;

        const initDB = () => {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    if (!db.objectStoreNames.contains('playlists')) {
                        db.createObjectStore('playlists', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('songs')) {
                        db.createObjectStore('songs', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings', { keyPath: 'key' });
                    }
                };
            });
        };

        const dbOperation = async (storeName, mode, operation) => {
            const db = await initDB();
            const tx = db.transaction(storeName, mode);
            const store = tx.objectStore(storeName);
            return operation(store);
        };

        // Storage Adapter (ready for Firebase in future)
        const StorageAdapter = {
            // Playlists
            async savePlaylists(playlists) {
                await dbOperation('playlists', 'readwrite', async (store) => {
                    // Clear existing
                    const clearReq = store.clear();
                    await new Promise(resolve => clearReq.onsuccess = resolve);
                    // Add all
                    for (const playlist of playlists) {
                        store.put(playlist);
                    }
                });
            },
            
            async loadPlaylists() {
                return dbOperation('playlists', 'readonly', (store) => {
                    return new Promise((resolve) => {
                        const request = store.getAll();
                        request.onsuccess = () => resolve(request.result || []);
                    });
                });
            },

            // Songs (blob data)
            async saveSong(song, blob) {
                await dbOperation('songs', 'readwrite', (store) => {
                    store.put({ id: song.id, blob, metadata: song });
                });
            },

            async loadSong(songId) {
                return dbOperation('songs', 'readonly', (store) => {
                    return new Promise((resolve) => {
                        const request = store.get(songId);
                        request.onsuccess = () => resolve(request.result);
                    });
                });
            },

            async deleteSong(songId) {
                await dbOperation('songs', 'readwrite', (store) => {
                    store.delete(songId);
                });
            },

            // Settings
            async saveSetting(key, value) {
                await dbOperation('settings', 'readwrite', (store) => {
                    store.put({ key, value });
                });
            },

            async loadSetting(key) {
                return dbOperation('settings', 'readonly', (store) => {
                    return new Promise((resolve) => {
                        const request = store.get(key);
                        request.onsuccess = () => resolve(request.result?.value);
                    });
                });
            }
        };

        function MusicPlayer() {
            const [playlists, setPlaylists] = useState([]);
            const [activePlaylist, setActivePlaylist] = useState(null);
            const [currentSong, setCurrentSong] = useState(null);
            const [isPlaying, setIsPlaying] = useState(false);
            const [repeat, setRepeat] = useState(false);
            const [shuffle, setShuffle] = useState(false);
            const [progress, setProgress] = useState(0);
            const [volume, setVolume] = useState(80);
            const [theme, setTheme] = useState('green');
            const [searchQuery, setSearchQuery] = useState('');
            const [sidebarOpen, setSidebarOpen] = useState(false);
            const [showPlaylistModal, setShowPlaylistModal] = useState(false);
            const [showUrlInput, setShowUrlInput] = useState(false);
            const [showExportImport, setShowExportImport] = useState(false);
            const [newPlaylistName, setNewPlaylistName] = useState('');
            const [urlInput, setUrlInput] = useState('');
            const [confirmDelete, setConfirmDelete] = useState(null);
            const [editingPlaylist, setEditingPlaylist] = useState(null);
            const [editingPlaylistName, setEditingPlaylistName] = useState('');
            const [editingSong, setEditingSong] = useState(null);
            const [editingSongName, setEditingSongName] = useState('');
            const [loading, setLoading] = useState(true);
            
            const audioRef = useRef(null);
            const fileInputRef = useRef(null);

            const themes = {
                green: { primary: '#1DB954', name: 'Spotify Green' },
                purple: { primary: '#8B5CF6', name: 'Purple' },
                blue: { primary: '#3B82F6', name: 'Blue' },
                pink: { primary: '#EC4899', name: 'Pink' },
                orange: { primary: '#F97316', name: 'Orange' }
            };

            // Load data on mount
            useEffect(() => {
                loadAllData();
            }, []);

            const loadAllData = async () => {
                try {
                    const [savedPlaylists, savedTheme, savedVolume, savedLastSong] = await Promise.all([
                        StorageAdapter.loadPlaylists(),
                        StorageAdapter.loadSetting('theme'),
                        StorageAdapter.loadSetting('volume'),
                        StorageAdapter.loadSetting('lastSong')
                    ]);

                    if (savedPlaylists) setPlaylists(savedPlaylists);
                    if (savedTheme) setTheme(savedTheme);
                    if (savedVolume) setVolume(savedVolume);
                    if (savedLastSong) {
                        const songData = await StorageAdapter.loadSong(savedLastSong.id);
                        if (songData) {
                            setCurrentSong({
                                ...savedLastSong,
                                url: songData.blob ? URL.createObjectURL(songData.blob) : savedLastSong.url
                            });
                        }
                    }
                } catch (error) {
                    console.error('Error loading data:', error);
                } finally {
                    setLoading(false);
                }
            };

            // Save playlists whenever they change
            useEffect(() => {
                if (!loading && playlists.length >= 0) {
                    StorageAdapter.savePlaylists(playlists);
                }
            }, [playlists, loading]);

            // Save settings
            useEffect(() => {
                if (!loading) {
                    StorageAdapter.saveSetting('theme', theme);
                }
            }, [theme, loading]);

            useEffect(() => {
                if (!loading) {
                    StorageAdapter.saveSetting('volume', volume);
                }
            }, [volume, loading]);

            useEffect(() => {
                if (!loading && currentSong) {
                    StorageAdapter.saveSetting('lastSong', {
                        id: currentSong.id,
                        name: currentSong.name,
                        playlistId: currentSong.playlistId,
                        isUrl: currentSong.isUrl,
                        url: currentSong.isUrl ? currentSong.url : null
                    });
                }
            }, [currentSong, loading]);

            // Audio management
            useEffect(() => {
                if (audioRef.current && currentSong) {
                    audioRef.current.src = currentSong.url;
                    audioRef.current.load();
                    
                    if (isPlaying) {
                        audioRef.current.play().catch(err => {
                            console.error('Play failed:', err);
                            setIsPlaying(false);
                        });
                    }
                }
            }, [currentSong]);

            useEffect(() => {
                if (audioRef.current && currentSong) {
                    if (isPlaying) {
                        audioRef.current.play().catch(err => {
                            console.error('Play failed:', err);
                            setIsPlaying(false);
                        });
                    } else {
                        audioRef.current.pause();
                    }
                }
            }, [isPlaying]);

            useEffect(() => {
                if (audioRef.current) {
                    audioRef.current.volume = volume / 100;
                }
            }, [volume]);

            const createPlaylist = () => {
                setShowPlaylistModal(true);
            };

            const handleCreatePlaylist = () => {
                if (newPlaylistName.trim()) {
                    const newPlaylist = {
                        id: Date.now(),
                        name: newPlaylistName.trim(),
                        songs: []
                    };
                    setPlaylists([...playlists, newPlaylist]);
                    setActivePlaylist(newPlaylist.id);
                    setNewPlaylistName('');
                    setShowPlaylistModal(false);
                    setSidebarOpen(false);
                }
            };

            const handleFileUpload = async (e) => {
                const files = Array.from(e.target.files);
                if (!activePlaylist) {
                    alert('Please select a playlist first');
                    return;
                }

                const playlist = playlists.find(p => p.id === activePlaylist);
                if (!playlist) return;

                for (const file of files) {
                    const songId = Date.now() + Math.random();
                    const song = {
                        id: songId,
                        name: file.name.replace(/\.[^/.]+$/, ''),
                        isUrl: false
                    };

                    // Save blob to IndexedDB
                    await StorageAdapter.saveSong(song, file);
                    
                    // Add to playlist
                    playlist.songs.push(song);
                }

                setPlaylists([...playlists]);
            };

            const handleUrlSubmit = () => {
                if (!urlInput.trim() || !activePlaylist) return;
                
                try {
                    new URL(urlInput);
                } catch {
                    alert('Please enter a valid URL');
                    return;
                }
                
                const playlist = playlists.find(p => p.id === activePlaylist);
                if (!playlist) return;

                const song = {
                    id: Date.now() + Math.random(),
                    name: urlInput.split('/').pop().split('?')[0] || 'Audio from URL',
                    url: urlInput,
                    isUrl: true
                };
                
                playlist.songs.push(song);
                setPlaylists([...playlists]);
                setUrlInput('');
                setShowUrlInput(false);
            };

            const playSong = async (song, playlistId) => {
                if (song.isUrl) {
                    setCurrentSong({ ...song, playlistId });
                } else {
                    const songData = await StorageAdapter.loadSong(song.id);
                    if (songData && songData.blob) {
                        setCurrentSong({
                            ...song,
                            playlistId,
                            url: URL.createObjectURL(songData.blob)
                        });
                    }
                }
                setIsPlaying(true);
            };

            const togglePlay = () => {
                setIsPlaying(!isPlaying);
            };

            const handleTimeUpdate = () => {
                if (audioRef.current && audioRef.current.duration) {
                    const prog = (audioRef.current.currentTime / audioRef.current.duration) * 100;
                    setProgress(prog || 0);
                }
            };

            const handleSongEnd = () => {
                if (repeat && audioRef.current) {
                    audioRef.current.currentTime = 0;
                    setIsPlaying(true);
                } else {
                    const playlist = playlists.find(p => p.id === currentSong?.playlistId);
                    if (playlist) {
                        const currentIndex = playlist.songs.findIndex(s => s.id === currentSong.id);
                        if (currentIndex < playlist.songs.length - 1) {
                            playSong(playlist.songs[currentIndex + 1], currentSong.playlistId);
                        } else {
                            setIsPlaying(false);
                        }
                    }
                }
            };

            const handleProgressClick = (e) => {
                if (audioRef.current && audioRef.current.duration) {
                    const rect = e.currentTarget.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const percentage = x / rect.width;
                    audioRef.current.currentTime = percentage * audioRef.current.duration;
                }
            };

            const deletePlaylist = (id) => {
                setConfirmDelete({ type: 'playlist', id });
            };

            const deleteSong = (playlistId, songId) => {
                setConfirmDelete({ type: 'song', playlistId, songId });
            };

            const confirmDeleteAction = async () => {
                if (confirmDelete.type === 'playlist') {
                    const playlist = playlists.find(p => p.id === confirmDelete.id);
                    if (playlist) {
                        // Delete all song blobs
                        for (const song of playlist.songs) {
                            if (!song.isUrl) {
                                await StorageAdapter.deleteSong(song.id);
                            }
                        }
                    }
                    setPlaylists(playlists.filter(p => p.id !== confirmDelete.id));
                    if (activePlaylist === confirmDelete.id) {
                        setActivePlaylist(null);
                    }
                } else if (confirmDelete.type === 'song') {
                    const playlist = playlists.find(p => p.id === confirmDelete.playlistId);
                    if (playlist) {
                        const song = playlist.songs.find(s => s.id === confirmDelete.songId);
                        if (song && !song.isUrl) {
                            await StorageAdapter.deleteSong(song.id);
                        }
                        playlist.songs = playlist.songs.filter(s => s.id !== confirmDelete.songId);
                        setPlaylists([...playlists]);
                    }
                }
                setConfirmDelete(null);
            };

            const exportPlaylists = () => {
                const dataStr = JSON.stringify(playlists, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `music-playlists-${Date.now()}.json`;
                link.click();
                URL.revokeObjectURL(url);
            };

            const importPlaylists = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const imported = JSON.parse(event.target.result);
                        if (Array.isArray(imported)) {
                            setPlaylists([...playlists, ...imported]);
                            alert(`Imported ${imported.length} playlists`);
                        }
                    } catch (error) {
                        alert('Invalid file format');
                    }
                };
                reader.readAsText(file);
            };

            const startEditPlaylist = (playlist) => {
                setEditingPlaylist(playlist.id);
                setEditingPlaylistName(playlist.name);
            };

            const saveEditPlaylist = (playlist) => {
                if (editingPlaylistName.trim()) {
                    playlist.name = editingPlaylistName.trim();
                    setPlaylists([...playlists]);
                    setEditingPlaylist(null);
                }
            };

            const startEditSong = (playlistId, song) => {
                setEditingSong({ playlistId, songId: song.id });
                setEditingSongName(song.name);
            };

            const saveEditSong = (playlistId, songId) => {
                if (editingSongName.trim()) {
                    const playlist = playlists.find(p => p.id === playlistId);
                    if (playlist) {
                        const song = playlist.songs.find(s => s.id === songId);
                        if (song) {
                            song.name = editingSongName.trim();
                            setPlaylists([...playlists]);
                        }
                    }
                    setEditingSong(null);
                }
            };

            const formatTime = (seconds) => {
                if (!seconds || isNaN(seconds)) return '0:00';
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            const currentPlaylist = playlists.find(p => p.id === activePlaylist);
            const primaryColor = themes[theme].primary;

            const filteredPlaylists = playlists.filter(p =>
                p.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
                p.songs.some(s => s.name.toLowerCase().includes(searchQuery.toLowerCase()))
            );

            if (loading) {
                return React.createElement('div', {
                    className: 'h-screen flex items-center justify-center bg-black'
                },
                    React.createElement('div', { className: 'text-2xl text-gray-400' }, 'Loading...')
                );
            }

            return React.createElement('div', { className: 'h-screen flex flex-col bg-black' },
                // Overlay
                React.createElement('div', {
                    className: `overlay ${sidebarOpen ? 'open' : ''}`,
                    onClick: () => setSidebarOpen(false)
                }),

                // Main Layout
                React.createElement('div', { className: 'flex flex-1 overflow-hidden' },
                    // Sidebar
                    React.createElement('div', {
                        className: `sidebar ${sidebarOpen ? 'open' : ''} md:relative md:left-0 w-64 bg-black p-4 md:p-6 flex flex-col gap-4 md:gap-6`
                    },
                        React.createElement('div', { className: 'flex items-center justify-between' },
                            React.createElement('div', { className: 'text-xl md:text-2xl font-bold' }, 'üéµ Music'),
                            React.createElement('button', {
                                onClick: () => setSidebarOpen(false),
                                className: 'md:hidden text-2xl text-gray-400'
                            }, '‚úï')
                        ),

                        // Theme Selector
                        React.createElement('div', { className: 'glass rounded-lg p-3' },
                            React.createElement('div', { className: 'text-xs font-semibold text-gray-400 mb-2 uppercase' }, 'Theme'),
                            React.createElement('div', { className: 'flex gap-2 flex-wrap' },
                                Object.keys(themes).map(t =>
                                    React.createElement('button', {
                                        key: t,
                                        onClick: () => setTheme(t),
                                        className: `w-8 h-8 rounded-full border-2 ${theme === t ? 'border-white scale-110' : 'border-transparent'}`,
                                        style: { backgroundColor: themes[t].primary },
                                        title: themes[t].name
                                    })
                                )
                            )
                        ),

                        // Actions
                        React.createElement('div', { className: 'flex flex-col gap-2' },
                            React.createElement('button', {
                                onClick: createPlaylist,
                                className: 'flex items-center gap-3 text-gray-400 hover:text-white transition p-2 rounded hover:bg-gray-900'
                            }, React.createElement('span', { className: 'text-xl' }, '‚ûï'), 'Create Playlist'),
                            React.createElement('button', {
                                onClick: () => setShowExportImport(true),
                                className: 'flex items-center gap-3 text-gray-400 hover:text-white transition p-2 rounded hover:bg-gray-900'
                            }, React.createElement('span', { className: 'text-xl' }, 'üì§'), 'Export/Import')
                        ),

                        React.createElement('div', { className: 'h-px bg-gray-800' }),

                        // Search
                        React.createElement('input', {
                            type: 'text',
                            placeholder: 'Search playlists...',
                            value: searchQuery,
                            onChange: (e) => setSearchQuery(e.target.value),
                            className: 'px-3 py-2 bg-gray-900 rounded outline-none text-sm'
                        }),

                        // Playlists
                        React.createElement('div', { className: 'flex-1 overflow-y-auto scrollbar-hide' },
                            React.createElement('div', { className: 'text-xs font-semibold text-gray-400 mb-3 uppercase' }, 'Your Playlists'),
                            React.createElement('div', { className: 'flex flex-col gap-2' },
                                filteredPlaylists.map(playlist =>
                                    React.createElement('div', {
                                        key: playlist.id,
                                        onClick: () => {
                                            setActivePlaylist(playlist.id);
                                            setSidebarOpen(false);
                                        },
                                        className: `px-3 py-2 rounded cursor-pointer transition group fade-in ${activePlaylist === playlist.id ? 'glass' : 'hover:bg-gray-900'}`,
                                        style: activePlaylist === playlist.id ? { borderColor: primaryColor } : {}
                                    },
                                        editingPlaylist === playlist.id
                                            ? React.createElement('input', {
                                                type: 'text',
                                                value: editingPlaylistName,
                                                onChange: (e) => setEditingPlaylistName(e.target.value),
                                                onBlur: () => saveEditPlaylist(playlist),
                                                onKeyPress: (e) => e.key === 'Enter' && saveEditPlaylist(playlist),
                                                className: 'w-full bg-gray-700 px-2 py-1 rounded text-white outline-none',
                                                autoFocus: true,
                                                onClick: (e) => e.stopPropagation()
                                            })
                                            : React.createElement('div', { className: 'flex items-center justify-between' },
                                                React.createElement('div', { className: 'flex-1 min-w-0' },
                                                    React.createElement('div', {
                                                        className: `font-medium truncate ${activePlaylist === playlist.id ? 'text-white' : 'text-white'}`,
                                                        style: activePlaylist === playlist.id ? { color: primaryColor } : {}
                                                    }, playlist.name),
                                                    React.createElement('div', { className: 'text-xs text-gray-400' }, `${playlist.songs.length} songs`)
                                                ),
                                                React.createElement('div', { className: 'flex gap-1 opacity-0 group-hover:opacity-100 transition' },
                                                    React.createElement('button', {
                                                        onClick: (e) => {
                                                            e.stopPropagation();
                                                            startEditPlaylist(playlist);
                                                        },
                                                        className: 'p-1 hover:text-blue-500'
                                                    }, '‚úèÔ∏è'),
                                                    React.createElement('button', {
                                                        onClick: (e) => {
                                                            e.stopPropagation();
                                                            deletePlaylist(playlist.id);
                                                        },
                                                        className: 'p-1 hover:text-red-500'
                                                    }, 'üóëÔ∏è')
                                                )
                                            )
                                    )
                                )
                            )
                        ),
